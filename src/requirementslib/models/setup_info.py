# -*- coding=utf-8 -*-
from __future__ import absolute_import, print_function

import contextlib
import os
import sys

import attr
import packaging.version
import packaging.specifiers
import packaging.utils
import six

try:
    from setuptools.dist import distutils
except ImportError:
    import distutils

from appdirs import user_cache_dir
from six.moves import configparser
from six.moves.urllib.parse import unquote
from vistir.compat import Path, Iterable
from vistir.contextmanagers import cd, temp_environ
from vistir.misc import run
from vistir.path import create_tracked_tempdir, ensure_mkdir_p, mkdir_p

from .utils import init_requirement, get_pyproject, get_name_variants
from ..environment import MYPY_RUNNING
from ..exceptions import RequirementError

try:
    from os import scandir
except ImportError:
    from scandir import scandir


if MYPY_RUNNING:
    from typing import Any, Dict, List, Generator, Optional, Union
    from pip_shims.shims import InstallRequirement
    from pkg_resources import Requirement as PkgResourcesRequirement


CACHE_DIR = os.environ.get("PIPENV_CACHE_DIR", user_cache_dir("pipenv"))

# The following are necessary for people who like to use "if __name__" conditionals
# in their setup.py scripts
_setup_stop_after = None
_setup_distribution = None


@contextlib.contextmanager
def _suppress_distutils_logs():
    # type: () -> None
    """Hack to hide noise generated by `setup.py develop`.

    There isn't a good way to suppress them now, so let's monky-patch.
    See https://bugs.python.org/issue25392.
    """

    f = distutils.log.Log._log

    def _log(log, level, msg, args):
        if level >= distutils.log.ERROR:
            f(log, level, msg, args)

    distutils.log.Log._log = _log
    yield
    distutils.log.Log._log = f


@ensure_mkdir_p(mode=0o775)
def _get_src_dir(root):
    # type: (str) -> str
    src = os.environ.get("PIP_SRC")
    if src:
        return src
    virtual_env = os.environ.get("VIRTUAL_ENV")
    if virtual_env is not None:
        return os.path.join(virtual_env, "src")
    if not root:
        # Intentionally don't match pip's behavior here -- this is a temporary copy
        src_dir = create_tracked_tempdir(prefix="requirementslib-", suffix="-src")
    else:
        src_dir = os.path.join(root, "src")
    return src_dir


def ensure_reqs(reqs):
    # type: (List[Union[str, PkgResourcesRequirement]]) -> List[PkgResourcesRequirement]
    import pkg_resources
    if not isinstance(reqs, Iterable):
        raise TypeError("Expecting an Iterable, got %r" % reqs)
    new_reqs = []
    for req in reqs:
        if not req:
            continue
        if isinstance(req, six.string_types):
            req = pkg_resources.Requirement.parse("{0}".format(str(req)))
        new_reqs.append(req)
    return new_reqs


def _prepare_wheel_building_kwargs(ireq=None, src_root=None, editable=False):
    # type: (Optional[InstallRequirement], Optional[str], bool) -> Dict[str, str]
    download_dir = os.path.join(CACHE_DIR, "pkgs")  # type: str
    mkdir_p(download_dir)

    wheel_download_dir = os.path.join(CACHE_DIR, "wheels")  # type: str
    mkdir_p(wheel_download_dir)

    if ireq is None:
        src_dir = _get_src_dir(root=src_root)  # type: str
    elif ireq is not None and ireq.source_dir is not None:
        src_dir = ireq.source_dir
    elif ireq is not None and ireq.editable:
        src_dir = _get_src_dir(root=src_root)
    else:
        src_dir = create_tracked_tempdir(prefix="reqlib-src")

    # This logic matches pip's behavior, although I don't fully understand the
    # intention. I guess the idea is to build editables in-place, otherwise out
    # of the source tree?
    if ireq is None and editable or (ireq is not None and ireq.editable):
        build_dir = src_dir
    else:
        build_dir = create_tracked_tempdir(prefix="reqlib-build")

    return {
        "build_dir": build_dir,
        "src_dir": src_dir,
        "download_dir": download_dir,
        "wheel_download_dir": wheel_download_dir,
    }


def iter_metadata(path, pkg_name=None, metadata_type="egg-info"):
    # type: (str, Optional[str], str) -> Generator
    if pkg_name is not None:
        pkg_variants = get_name_variants(pkg_name)
    non_matching_dirs = []
    for entry in scandir(path):
        if entry.is_dir():
            entry_name, ext = os.path.splitext(entry.name)
            if ext.endswith(metadata_type):
                if pkg_name is None or entry_name.lower() in pkg_variants:
                    yield entry
            elif not entry.name.endswith(metadata_type):
                non_matching_dirs.append(entry)
    for entry in non_matching_dirs:
        for dir_entry in iter_metadata(entry.path, pkg_name=pkg_name, metadata_type=metadata_type):
            yield dir_entry


def find_egginfo(target, pkg_name=None):
    # type: (str, Optional[str]) -> Generator
    egg_dirs = (egg_dir for egg_dir in iter_metadata(target, pkg_name=pkg_name))
    if pkg_name:
        yield next(iter(egg_dirs), None)
    else:
        for egg_dir in egg_dirs:
            yield egg_dir


def find_distinfo(target, pkg_name=None):
    # type: (str, Optional[str]) -> Generator
    dist_dirs = (dist_dir for dist_dir in iter_metadata(target, pkg_name=pkg_name, metadata_type="dist-info"))
    if pkg_name:
        yield next(iter(dist_dirs), None)
    else:
        for dist_dir in dist_dirs:
            yield dist_dir


def get_metadata(path, pkg_name=None):
    egg_dir = next(iter(find_egginfo(path, pkg_name=pkg_name)), None)
    dist_dir = next(iter(find_distinfo(path, pkg_name=pkg_name)), None)
    matched_dir = next(iter(d for d in (dist_dir, egg_dir) if d is not None), None)
    metadata_dir = None
    base_dir = None
    if matched_dir is not None:
        import pkg_resources
        metadata_dir = os.path.abspath(matched_dir.path)
        base_dir = os.path.dirname(metadata_dir)
        dist = None
        distinfo_dist = None
        egg_dist = None
        if dist_dir is not None:
            distinfo_dist = next(iter(pkg_resources.find_distributions(base_dir)), None)
        if egg_dir is not None:
            path_metadata = pkg_resources.PathMetadata(base_dir, metadata_dir)
            egg_dist = next(
                iter(pkg_resources.distributions_from_metadata(path_metadata.egg_info)),
                None,
            )
        dist = next(iter(d for d in (distinfo_dist, egg_dist) if d is not None), None)
        if dist:
            try:
                requires = dist.requires()
            except Exception:
                requires = []
            try:
                dep_map = dist._build_dep_map()
            except Exception:
                dep_map = {}
            deps = []
            extras = {}
            for k in dep_map.keys():
                if k is None:
                    deps.extend(dep_map.get(k))
                    continue
                else:
                    extra = None
                    _deps = dep_map.get(k)
                    if k.startswith(":python_version"):
                        marker = k.replace(":", "; ")
                    else:
                        marker = ""
                        extra = "{0}".format(k)
                    _deps = ["{0}{1}".format(str(req), marker) for req in _deps]
                    _deps = ensure_reqs(_deps)
                    if extra:
                        extras[extra] = _deps
                    else:
                        deps.extend(_deps)
            return {
                "name": dist.project_name,
                "version": dist.version,
                "requires": requires,
                "extras": extras
            }


@attr.s(slots=True, frozen=True)
class BaseRequirement(object):
    name = attr.ib(type=str, default="", cmp=True)
    requirement = attr.ib(default=None, cmp=True)  # type: Optional[PkgResourcesRequirement]

    def __str__(self):
        return "{0}".format(str(self.requirement))

    def as_dict(self):
        return {self.name: self.requirement}

    def as_tuple(self):
        return (self.name, self.requirement)

    @classmethod
    def from_string(cls, line):
        line = line.strip()
        req = init_requirement(line)
        return cls.from_req(req)

    @classmethod
    def from_req(cls, req):
        name = None
        key = getattr(req, "key", None)
        name = getattr(req, "name", None)
        project_name = getattr(req, "project_name", None)
        if key is not None:
            name = key
        if name is None:
            name = project_name
        return cls(name=name, requirement=req)


@attr.s(slots=True, cmp=False)
class SetupInfo(object):
    name = attr.ib(type=str, default=None, cmp=True)
    base_dir = attr.ib(type=Path, default=None, cmp=True, hash=False)
    version = attr.ib(type=str, default=None, cmp=True)
    _requirements = attr.ib(type=tuple, default=attr.Factory(tuple), cmp=True)
    build_requires = attr.ib(type=tuple, default=attr.Factory(tuple), cmp=True)
    build_backend = attr.ib(type=str, default="setuptools.build_meta", cmp=True)
    setup_requires = attr.ib(type=tuple, default=attr.Factory(tuple), cmp=True)
    python_requires = attr.ib(type=packaging.specifiers.SpecifierSet, default=None, cmp=True)
    _extras_requirements = attr.ib(type=tuple, default=attr.Factory(tuple), cmp=True)
    setup_cfg = attr.ib(type=Path, default=None, cmp=True, hash=False)
    setup_py = attr.ib(type=Path, default=None, cmp=True, hash=False)
    pyproject = attr.ib(type=Path, default=None, cmp=True, hash=False)
    ireq = attr.ib(default=None, cmp=True, hash=False)
    extra_kwargs = attr.ib(default=attr.Factory(dict), type=dict, cmp=False, hash=False)

    @property
    def requires(self):
        return {req.name: req.requirement for req in self._requirements}

    @property
    def extras(self):
        extras_dict = {}
        extras = set(self._extras_requirements)
        for section, deps in extras:
            if isinstance(deps, BaseRequirement):
                extras_dict[section] = deps.requirement
            elif isinstance(deps, (list, tuple)):
                extras_dict[section] = [d.requirement for d in deps]
        return extras_dict

    @classmethod
    def get_setup_cfg(cls, setup_cfg_path):
        if os.path.exists(setup_cfg_path):
            default_opts = {
                "metadata": {"name": "", "version": ""},
                "options": {
                    "install_requires": "",
                    "python_requires": "",
                    "build_requires": "",
                    "setup_requires": "",
                    "extras": "",
                },
            }
            parser = configparser.ConfigParser(default_opts)
            parser.read(setup_cfg_path)
            results = {}
            if parser.has_option("metadata", "name"):
                results["name"] = parser.get("metadata", "name")
            if parser.has_option("metadata", "version"):
                results["version"] = parser.get("metadata", "version")
            install_requires = ()
            if parser.has_option("options", "install_requires"):
                install_requires = tuple([
                    BaseRequirement.from_string(dep)
                    for dep in parser.get("options", "install_requires").split("\n")
                    if dep
                ])
            results["install_requires"] = install_requires
            if parser.has_option("options", "python_requires"):
                results["python_requires"] = parser.get("options", "python_requires")
            extras_require = ()
            if "options.extras_require" in parser.sections():
                extras_require = tuple([
                    (section, tuple([
                        BaseRequirement.from_string(dep)
                        for dep in parser.get(
                            "options.extras_require", section
                        ).split("\n")
                        if dep
                    ]))
                    for section in parser.options("options.extras_require")
                    if section not in ["options", "metadata"]
                ])
            results["extras_require"] = extras_require
            return results

    def parse_setup_cfg(self):
        if self.setup_cfg is not None and self.setup_cfg.exists():
            parsed = self.get_setup_cfg(self.setup_cfg.as_posix())
            if self.name is None:
                self.name = parsed.get("name")
            if self.version is None:
                self.version = parsed.get("version")
            self._requirements = self._requirements + parsed["install_requires"]
            if self.python_requires is None:
                self.python_requires = parsed.get("python_requires")
            if not self._extras_requirements:
                self._extras_requirements = (parsed["extras_require"])
            else:
                self._extras_requirements = self._extras_requirements + parsed["extras_require"]
            if self.ireq is not None and self.ireq.extras:
                for extra in self.ireq.extras:
                    if extra in self.extras:
                        extras_tuple = tuple([BaseRequirement.from_req(req) for req in self.extras[extra]])
                        self._extras_requirements += ((extra, extras_tuple),)

    def run_setup(self):
        if self.setup_py is not None and self.setup_py.exists():
            target_cwd = self.setup_py.parent.as_posix()
            with cd(target_cwd), _suppress_distutils_logs():
                # This is for you, Hynek
                # see https://github.com/hynek/environ_config/blob/69b1c8a/setup.py
                script_name = self.setup_py.as_posix()
                args = ["egg_info"]
                g = {"__file__": script_name, "__name__": "__main__"}
                local_dict = {}
                if sys.version_info < (3, 5):
                    save_argv = sys.argv
                else:
                    save_argv = sys.argv.copy()
                try:
                    global _setup_distribution, _setup_stop_after
                    _setup_stop_after = "run"
                    sys.argv[0] = script_name
                    sys.argv[1:] = args
                    with open(script_name, 'rb') as f:
                        if sys.version_info < (3, 5):
                            exec(f.read(), g, local_dict)
                        else:
                            exec(f.read(), g)
                # We couldn't import everything needed to run setup
                except NameError:
                    python = os.environ.get('PIP_PYTHON_PATH', sys.executable)
                    out, _ = run([python, "setup.py"] + args, cwd=target_cwd, block=True,
                                 combine_stderr=False, return_object=False, nospin=True)
                except SystemExit:
                    print("Current directory: %s\nTarget file: %s\nDirectory Contents: %s\nSetup Path Contents: %s\n" % (
                        os.getcwd(), script_name, os.listdir(os.getcwd()), os.listdir(os.path.dirname(script_name))))
                finally:
                    _setup_stop_after = None
                    sys.argv = save_argv
                dist = _setup_distribution
                if not dist:
                    self.get_egg_metadata()
                    return

                name = dist.get_name()
                if name:
                    self.name = name
                if dist.python_requires and not self.python_requires:
                    self.python_requires = packaging.specifiers.SpecifierSet(
                        dist.python_requires
                    )
                if not self._extras_requirements:
                    self._extras_requirements = ()
                if dist.extras_require and not self.extras:
                    for extra, extra_requires in dist.extras_require:
                        extras_tuple = tuple(
                            BaseRequirement.from_req(req) for req in extra_requires
                        )
                        self._extras_requirements += ((extra, extras_tuple),)
                install_requires = dist.get_requires()
                if not install_requires:
                    install_requires = dist.install_requires
                if install_requires and not self.requires:
                    requirements = [init_requirement(req) for req in install_requires]
                    if getattr(self.ireq, "extras", None):
                        for extra in self.ireq.extras:
                            requirements.extend(list(self.extras.get(extra, [])))
                    self._requirements = self._requirements + tuple([
                        BaseRequirement.from_req(req) for req in requirements
                    ])
                if dist.setup_requires and not self.setup_requires:
                    self.setup_requires = tuple(dist.setup_requires)
                if not self.version:
                    self.version = dist.get_version()

    def get_egg_metadata(self):
        if self.setup_py is not None and self.setup_py.exists():
            metadata = get_metadata(self.setup_py.parent.as_posix(), pkg_name=self.name)
            if metadata:
                if self.name is None:
                    self.name = metadata.get("name", self.name)
                if not self.version:
                    self.version = metadata.get("version", self.version)
                self._requirements = self._requirements + tuple([
                    BaseRequirement.from_req(req) for req in metadata.get("requires", [])
                ])
                if getattr(self.ireq, "extras", None):
                    for extra in self.ireq.extras:
                        extras = metadata.get("extras", {}).get(extra, [])
                        if extras:
                            extras_tuple = tuple([
                                BaseRequirement.from_req(req)
                                for req in ensure_reqs(extras)
                                if req is not None
                            ])
                            self._extras_requirements += ((extra, extras_tuple),)
                            self._requirements = self._requirements + extras_tuple

    def run_pyproject(self):
        if self.pyproject and self.pyproject.exists():
            result = get_pyproject(self.pyproject.parent)
            if result is not None:
                requires, backend = result
                if backend:
                    self.build_backend = backend
                if requires and not self.build_requires:
                    self.build_requires = tuple(requires)

    def get_info(self):
        initial_path = os.path.abspath(os.getcwd())
        if self.setup_cfg and self.setup_cfg.exists():
            with cd(self.base_dir):
                self.parse_setup_cfg()
        if self.setup_py and self.setup_py.exists():
            if not self.requires or not self.name:
                try:
                    with cd(self.base_dir):
                        self.run_setup()
                except Exception:
                    with cd(self.base_dir):
                        self.get_egg_metadata()
                if not self.requires or not self.name:
                    with cd(self.base_dir):
                        self.get_egg_metadata()

        if self.pyproject and self.pyproject.exists():
            try:
                with cd(self.base_dir):
                    self.run_pyproject()
            finally:
                os.chdir(initial_path)
        return self.as_dict()

    def as_dict(self):
        # type: () -> Dict[str, Any]
        prop_dict = {
            "name": self.name,
            "version": self.version,
            "base_dir": self.base_dir,
            "ireq": self.ireq,
            "build_backend": self.build_backend,
            "build_requires": self.build_requires,
            "requires": self.requires,
            "setup_requires": self.setup_requires,
            "python_requires": self.python_requires,
            "extras": self.extras,
            "extra_kwargs": self.extra_kwargs,
            "setup_cfg": self.setup_cfg,
            "setup_py": self.setup_py,
            "pyproject": self.pyproject,
        }
        return {k: v for k, v in prop_dict.items() if v}

    @classmethod
    def from_requirement(cls, requirement, finder=None):
        ireq = requirement.as_ireq()
        subdir = getattr(requirement.req, "subdirectory", None)
        return cls.from_ireq(ireq, subdir=subdir, finder=finder)

    @classmethod
    def from_ireq(cls, ireq, subdir=None, finder=None):
        import pip_shims.shims
        if not ireq.link:
            return
        if ireq.link.is_wheel:
            return
        if not finder:
            from .dependencies import get_finder

            finder = get_finder()
        kwargs = _prepare_wheel_building_kwargs(ireq)
        ireq.populate_link(finder, False, False)
        ireq.ensure_has_source_dir(kwargs["build_dir"])
        if not (
            ireq.editable
            and pip_shims.shims.is_file_url(ireq.link)
            and not ireq.link.is_artifact
        ):
            if ireq.is_wheel:
                only_download = True
                download_dir = kwargs["wheel_download_dir"]
            else:
                only_download = False
                download_dir = kwargs["download_dir"]
        ireq_src_dir = None
        if ireq.link.scheme == "file":
            path = pip_shims.shims.url_to_path(unquote(ireq.link.url_without_fragment))
            if pip_shims.shims.is_installable_dir(path):
                ireq_src_dir = path
            elif os.path.isdir(path):
                raise RequirementError(
                    "The file URL points to a directory not installable: {}"
                    .format(ireq.link)
                )

        if not (ireq.editable and "file" in ireq.link.scheme):
            pip_shims.shims.unpack_url(
                ireq.link,
                ireq.source_dir,
                download_dir,
                only_download=only_download,
                session=finder.session,
                hashes=ireq.hashes(False),
                progress_bar="off",
            )
        if ireq.editable:
            created = cls.create(
                ireq.source_dir, subdirectory=subdir, ireq=ireq, kwargs=kwargs
            )
        else:
            build_dir = ireq.build_location(kwargs["build_dir"])
            ireq._temp_build_dir.path = kwargs["build_dir"]
            created = cls.create(
                build_dir, subdirectory=subdir, ireq=ireq, kwargs=kwargs
            )
        return created

    @classmethod
    def create(cls, base_dir, subdirectory=None, ireq=None, kwargs=None):
        if not base_dir or base_dir is None:
            return

        creation_kwargs = {"extra_kwargs": kwargs}
        if not isinstance(base_dir, Path):
            base_dir = Path(base_dir)
        creation_kwargs["base_dir"] = base_dir.as_posix()
        pyproject = base_dir.joinpath("pyproject.toml")

        if subdirectory is not None:
            base_dir = base_dir.joinpath(subdirectory)
        setup_py = base_dir.joinpath("setup.py")
        setup_cfg = base_dir.joinpath("setup.cfg")
        creation_kwargs["pyproject"] = pyproject
        creation_kwargs["setup_py"] = setup_py
        creation_kwargs["setup_cfg"] = setup_cfg
        if ireq:
            creation_kwargs["ireq"] = ireq
        created = cls(**creation_kwargs)
        created.get_info()
        return created
